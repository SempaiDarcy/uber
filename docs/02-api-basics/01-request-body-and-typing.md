# Request body, типизация и создание сущностей

В данном разделе зафиксированы ключевые принципы работы с входными данными
в REST API на Node.js + Express + TypeScript.

Цель раздела — зафиксировать понимание:
- откуда берутся данные при создании сущности
- какие поля контролирует клиент, а какие сервер
- как TypeScript реально проверяет типы
- почему `as` может скрывать ошибки

---

## 1. Откуда берутся данные при POST-запросе

При создании новой сущности используется HTTP-метод POST.

```text
Client → POST /drivers → request body → Server → DB
```

Источник данных при создании **всегда `req.body`**.

База данных:
- не источник данных
- а место хранения результата

POST-запрос **создаёт** сущность, а не читает её.

---

## 2. Серверные и клиентские поля

При создании водителя поля делятся на две группы.

### Поля, приходящие от клиента

- name
- phoneNumber
- email
- vehicleMake
- vehicleModel
- vehicleYear
- vehicleLicensePlate
- vehicleDescription
- vehicleFeatures

Эти данные передаются через `req.body`.

---

### Поля, генерируемые сервером

- id
- status
- createdAt

Эти поля:
- не должны приходить от клиента
- контролируются сервером
- определяют состояние сущности

Пример корректного создания сущности:

```ts
const newDriver: Driver = {
  id: generateId(),
  status: DriverStatus.Online,
  createdAt: new Date(),
  ...validatedBody
};
```

---

## 3. Почему нельзя слепо использовать `...req.body`

Использование `...req.body` допустимо **только после валидации**.

Без валидации клиент может прислать лишние поля:

```json
{
  "status": "offline",
  "createdAt": "2020-01-01"
}
```

Если использовать `...req.body` напрямую,
сервер потеряет контроль над контрактом API.

Поэтому в учебных примерах поля часто перечисляются явно.

---

## 4. DTO как контракт входных данных

Для разделения входных данных и сущности используется DTO.

```ts
export type DriverInputDto = {
  name: string;
  phoneNumber: string;
  email: string;
  vehicleMake: string;
  vehicleModel: string;
  vehicleYear: number;
  vehicleLicensePlate: string;
  vehicleDescription: string | null;
  vehicleFeatures: VehicleFeature[];
};
```

DTO:
- описывает, **что может прислать клиент**
- не содержит серверных полей
- защищает API-контракт

---

## 5. Почему TypeScript «не ругается» в InMemoryDB

В InMemoryDB использовался следующий код:

```ts
drivers: <Driver[]>[
  { ... }
]
```

Это **type assertion**, а не типизация.

Type assertion (`as Type` / `<Type>`) означает:
> «Доверься мне, я знаю, что делаю».

В этом случае TypeScript **не проверяет структуру объекта**.

---

## 6. Разница между `: Type` и `as Type`

### Типизация (проверка включена)

```ts
const drivers: Driver[] = [
  {
    id: 1,
    // ошибка: нет status
  }
];
```

### Type assertion (проверка выключена)

```ts
const drivers = [
  {
    id: 1
  }
] as Driver[];
```

Использование `as` допустимо:
- при работе с внешними API
- при миграции legacy-кода

Для данных, которые контролируются внутри проекта,
`as` использовать не рекомендуется.

---

## 7. Вывод

- `req.body` — источник данных при POST
- база данных не участвует в создании сущности
- серверные поля не должны приходить от клиента
- DTO — контракт входных данных
- `as Type` отключает проверку типов
- строгая типизация требует `: Type`

Данный раздел фиксирует архитектурное понимание,
а не копирование учебных примеров.
